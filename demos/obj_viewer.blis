@vertex vec4 vshader(uniform mat4x4 xform, uniform mat4x4 world_xform,
                     vec3 pos, vec3 normal,
                     out vec3 world_pos, out vec3 world_normal)
{
  vec4 pos = vec4(pos.x, pos.y, pos.z, 1.);
  vec4 tmp = world_xform * pos;
  world_pos = vec3(tmp.x, tmp.y, tmp.z);
  tmp = world_xform * vec4(normal.x, normal.y, normal.z, 0.);
  world_normal = vec3(tmp.x, tmp.y, tmp.z);
  return xform * pos;
}

@fragment void fshader(vec3 world_pos,
                       vec3 world_normal,
                       uniform vec3 light_pos,
                       uniform vec4 light_ambient,
                       uniform vec4 light_diffuse,
                       uniform vec4 light_specular,
                       uniform vec4 mat_ambient,
                       uniform vec4 mat_diffuse,
                       uniform vec4 mat_specular,
                       uniform float mat_shininess,
                       uniform vec3 eye_pos,
                       out vec4 color)
{
  vec3 viewer_dir = normalize3(eye_pos - world_pos);
  vec3 light_dir = normalize3(light_pos - world_pos);
  vec3 half = normalize3(light_dir + viewer_dir);

  vec4 ambient_color = mat_ambient * light_ambient;

  float dd = dot3(light_dir, world_normal);
  if (dd < 0.)
    dd = 0.;

  vec4 diffuse_color = dd * light_diffuse * mat_diffuse;

  dd = dot3(half, world_normal);
  vec4 specular_color;
  if (dd > 0.0)
    specular_color = pow(dd, mat_shininess) * light_specular * mat_specular;
  else
    specular_color = vec4(0.0, 0.0, 0.0, 1.0);

  color = ambient_color + diffuse_color + specular_color;
}

vec3[] calc_smooth_normals(vec3[] verts, int[] tris)
{
  vec3[] normals = vec3[](length(verts));
  int i;
  for (i = 0; i < length(verts); i++) {
    normals[i] = vec3(0., 0., 0.);
  }

  for (i = 0; i < length(tris); i = i + 3) {
    vec3 a = verts[tris[i]];
    vec3 b = verts[tris[i + 1]];
    vec3 c = verts[tris[i + 2]];

    vec3 normal = normalize3(cross(b - a, c - a));
    normals[tris[i]] = normals[tris[i]] + normal;
    normals[tris[i + 1]] = normals[tris[i + 1]] + normal;
    normals[tris[i + 2]] = normals[tris[i + 2]] + normal;
  }

  for (i = 0; i < length(normals); i++)
    normals[i] = normalize3(normals[i]);

  return normals;
}

pipeline my_pipeline {
  @vertex vshader;
  @fragment fshader;
};

void set_camera_pos(pipeline my_pipeline p, float theta, float phi, float distance)
{
  mat4x4 ctm = rotate_y(theta) * rotate_z(phi);
  vec4 eye_point = ctm * vec4(distance, 0., 0., 1.);
  vec3 eye_point = vec3(eye_point.x, eye_point.y, eye_point.z);
  mat4x4 camera = look_at(eye_point, vec3(0., 0., 0.) /* at */,
                          vec3(0., 1., 0.) /* up */);
  mat4x4 proj = perspective(45. /* degrees */, 1., 0.5, 50.);
  p.eye_pos = eye_point;
  p.world_xform = identity();
  p.xform = proj * camera;
}

int main()
{
  vec3[] verts;
  int[] tris;

  if (!read_obj("./kitten.obj", verts, tris)) {
    print("error reading obj file\n");
    return 1;
  }

  window win = window(1024, 768, false);

  set_active_window(win);

  buffer<vec3> b = buffer<vec3>();
  buffer<int> indices = buffer<int>();
  buffer<vec3> normals = buffer<vec3>();

  upload_buffer(b, verts);
  upload_buffer(indices, tris);
  upload_buffer(normals, calc_smooth_normals(verts, tris));

  pipeline my_pipeline p = pipeline my_pipeline(true);
  p.pos = b;
  p.normal = normals;
  p.indices = indices;

  p.light_pos = vec3(100., 100., 100.);
  p.light_ambient = vec4(0.2, 0.2, 0.2, 1.0);
  p.light_diffuse = vec4(1.0, 1.0, 1.0, 1.0);
  p.light_specular = vec4(1.0, 1.0, 1.0, 1.0);

  p.mat_ambient = vec4(1.0, 0.0, 1.0, 1.0);
  p.mat_diffuse = vec4(1.0, 0.8, 0.0, 1.0);
  p.mat_specular = p.mat_diffuse;
  p.mat_shininess = 100.;

  while (true) {
    set_camera_pos(p, 0., 0., 1.);
    clear(vec4(1., 1., 1., 1.));
    draw(p, length(tris));
    swap_buffers(win);
    poll_events();
    if (window_should_close(win))
      break;
  }

  return 0;
}
